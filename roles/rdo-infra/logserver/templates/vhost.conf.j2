<VirtualHost *:80>
    DocumentRoot /var/www/html/{{ domain }}
    ServerName {{ domain }}

    # Redirect HTTP to HTTPS
    RewriteEngine On
    RewriteCond %{HTTPS} !=on
    RewriteRule ^/?(.*) https://%{SERVER_NAME}/$1 [R,L]
</VirtualHost>

<VirtualHost *:443>
    DocumentRoot /var/www/html/{{ domain }}
    ServerName {{ domain }}

    ErrorLog /var/log/httpd/{{ domain }}-error.log
    LogLevel warn
    CustomLog /var/log/httpd/{{ domain }}-access.log combined

    SSLEngine on
    SSLProtocol             ALL -SSLv2 -SSLv3
    SSLCertificateFile /etc/httpd/ssl/{{ domain }}/cert.pem
    SSLCertificateKeyFile /etc/httpd/ssl/{{ domain }}/privkey.pem

    AddType text/plain .log
    AddType text/plain .sh
    AddType text/plain .yaml
    AddType text/plain .yml

    # use Apache to compress the results afterwards, to save on the wire
    # it's approx 18x savings of wire traffic to compress. We need to
    # compress by content types that htmlify can produce
    AddOutputFilterByType DEFLATE text/plain text/html application/x-font-ttf image/svg+xml

    <FilesMatch \.html\.gz$>
        ForceType text/html
        AddDefaultCharset UTF-8
        AddEncoding x-gzip gz
    </FilesMatch>
    <FilesMatch \.txt\.gz$>
        ForceType text/plain
        AddDefaultCharset UTF-8
        AddEncoding x-gzip gz
    </FilesMatch>
    <FilesMatch \.log\.gz$>
        ForceType text/plain
        AddDefaultCharset UTF-8
        AddEncoding x-gzip gz
    </FilesMatch>
    <FilesMatch \.css\.gz$>
        ForceType text/css
        AddDefaultCharset UTF-8
        AddEncoding x-gzip gz
    </FilesMatch>
    <FilesMatch \.js\.gz$>
        ForceType text/javascript
        AddDefaultCharset UTF-8
        AddEncoding x-gzip gz
    </FilesMatch>
    <FilesMatch \.ttf\.gz$>
        ForceType application/x-font-ttf
        AddEncoding x-gzip gz
    </FilesMatch>
    <FilesMatch \.svg\.gz$>
        ForceType image/svg+xml
        AddEncoding x-gzip gz
    </FilesMatch>
    <FilesMatch \.css$>
        # mod_mime_magic is sometimes passing css files as asm sources
        # e.g css files generated by coverage reports
        ForceType text/css
    </FilesMatch>
    <Directory /var/www/cgi-bin/os-loganalyze>
        Allow from all
        Satisfy Any
    </Directory>

    IndexOptions NameWidth=*

    RewriteEngine On
    # If the specified file does not exist, look if there is a gzipped version
    # If there is, serve that one instead
    RewriteCond %{DOCUMENT_ROOT}%{REQUEST_FILENAME} !-f
    RewriteCond %{DOCUMENT_ROOT}%{REQUEST_FILENAME}.gz -f
    RewriteRule ^/(.*)$ %{REQUEST_URI}.gz

    # rewrite txt.gz & console.html[.gz] files to map to our internal htmlify
    # wsgi app
    # PT, Pass-through:  to come back around and get picked up by the
    #                    WSGIScriptAlias
    # NS, No-subrequest: on coming back through, mod-autoindex may have added
    #                    index.html which would match the !-f condition. We
    #                    therefore ensure the rewrite doesn't trigger by
    #                    disallowing subrequests.
    RewriteRule ^/(.*\.txt\.gz)$ /htmlify/$1 [QSA,L,PT,NS]
    RewriteRule ^/(.*console\.html(\.gz)?)$ /htmlify/$1 [QSA,L,PT,NS]

    # Check if the request exists as a file, directory or symbolic link
    # If not, write the request to htmlify to see if we can fetch from swift
    RewriteCond %{DOCUMENT_ROOT}%{REQUEST_FILENAME} !-f
    RewriteCond %{DOCUMENT_ROOT}%{REQUEST_FILENAME} !-d
    RewriteCond %{DOCUMENT_ROOT}%{REQUEST_FILENAME} !-l
    RewriteCond %{REQUEST_FILENAME} !^/icon
    RewriteRule ^/(.*)$ /htmlify/$1 [QSA,L,PT,NS]

    SetEnv OS_LOGANALYZE_ROOT_PATH /var/www/html/{{ domain }}
    WSGIScriptAlias /htmlify /var/www/cgi-bin/os-loganalyze/os_loganalyze/wsgi.py
    ServerSignature Off
</VirtualHost>
